# 클로저

클로저란 함수와 함수가 선언되었을 때의 렉시컬 환경의 조합

- 자신이 `선언된 당시의 환경을 기억`하는 함수
- 생명 주기가 끝난 `외부 함수의 변수`에 `접근`할 수 있는 내부 함수
- 클로저 = `함수` + `렉시컬 스코프`
- JS의 모든 함수는 자신이 선언된 환경의 주소를 저장. 즉, 상위 스코프의 주소를 가지고 있다.
- 상위 스코프의 주소를 참조하여 외부 함수의 변수에도 접근할 수 있게 된다.

## 클로저를 사용하는 이유

### 1. 상태 유지

- 현재 상태를 기억하고 변경된 최신 상태를 유지할 수 있다.

```js
function debounce(callback, delay) {
  let timer = null;

  return function () {
    clearTimeout(timer);
    timer = setTimeout(() => {
      callback.apply(this, arguments);
    }, delay);
  };
}
```

- 익명 함수는 debounce 내에서 선언되었으므로 debounce 함수가 상위 스코프가 됩니다.
- 함수는 선언된 환경의 주소를 기억하기 때문에 상위 스코프의 변수에 접근할 수 있게 되고, timer 변수에 접근할 수 있게 됩니다
- timer는 디바운스가 실행될 함수와 다른 스코프에 있기 때문에 timer에 대한 최신 상태를 유지할 수 있습니다.

### 2. 정보 은닉

- 변수 값을 은닉할 수 있다.

### 3. 전역 변수 사용 억제

- 클로저를 사용하면 변수를 공유하는 특성은 유지하되 데이터를 은닉화할 수 있기 때문에, 전역 변수를 대체하여 안전한 코드 작성

## 주의할 점

- 메모리 측면에서 손해이므로 조심히 사용한다.
